
<a name="B09Mv"></a>
# 第一天

<a name="SnX90"></a>
## 登录需求

[点击查看【processon】](https://www.processon.com/view/link/626bd4296376891e1c1b217e)

- 视图组件和复用组件的区分
- 封装请求类方法，aixos实例和接口方法分开封装。
- 注意token的操作以及保存。
- 将token需求的操作统一放在axios请求拦截器中。
- axios的响应拦截器中的操作，**判断200系的错误响应**，应该处理。
- 接收的**冗长的对象**可以在响应到的一刻进行解构，取出需要的部分
- 注意**跨域代理问题**。判断target和pathRewrite应如何使用（根据后台是否做相应的处理）
- 多处使用的数据可以放在store中，同理多处使用的方法也应放入store中执行（页面中相应的地方只做触发器）


<a name="f2h0D"></a>
# 第二天

<a name="RDQ4X"></a>
## 登录退出及路由的优化

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2830747/1651312773146-fba70492-0b5f-4cd7-92f2-a9abc7ed6dda.png#clientId=u024753ad-2fe3-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=497&id=uf07c4cc2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=621&originWidth=796&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36935&status=done&style=stroke&taskId=u6be7e84c-fc13-4e2f-926a-5f0990df559&title=&width=636.8)<br />在路由前置守卫中对路由的跳转进行截取判定: <br />除开登陆页面及白名单里的页面，所有的页面都需要在头部带上token才运行访问。<br />如果没有token，则不允许访问需要token的页面，强制为用户跳转至登录页。

在拥有token时不允许进入登录页。如果要到登录页，因走正常退出流程，在流程中删除已储存的token和用户信息。在拥有token时强制转跳用户前往登录页的所有行为。

使用Nprogress插件为页面的跳转添加加载动画。<br />路由发生改变时动画开始加载。路由跳转完成后动画结束，所以在路由前置守卫中开始动画，在后置守卫中结束动画。同时，所有指定地址的跳转，都应该额外再加一个结束动画的方法。
<a name="Bp1Lu"></a>
## 主页侧边栏与顶部栏的调整

侧边栏与顶部栏的数据从后台获取的信息中渲染。侧边栏的菜单基于当前用户的角色权限而动态生成。所有用户的个人信息字符都可以使用getters快捷访问来便捷渲染。


<a name="dhvk2"></a>
## 个人信息的获取
![image.png](https://cdn.nlark.com/yuque/0/2022/png/2830747/1651312895903-382c27da-fc17-4fbf-a4be-c21c26b773b4.png#clientId=u024753ad-2fe3-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=463&id=uf3a985ca&margin=%5Bobject%20Object%5D&name=image.png&originHeight=579&originWidth=1212&originalType=binary&ratio=1&rotation=0&showTitle=false&size=98387&status=done&style=none&taskId=ue07f5362-6b1f-4486-ac12-e86f799e59e&title=&width=969.6)<br />在路由发生变化且拥有token时，获取用户信息并存储在vuex中。所有的相关操作都在路由前置守卫中进行



<a name="f5x72"></a>
# 第三天

<a name="fAWyP"></a>
## 总结项目中有关axios及其拦截器的应用


<a name="lq1mA"></a>
### 1.编写项目中所有请求接口的相关方法


axios在项目中 一般的、正确的、正义的、正面的、可行的、主观的、毋庸置疑的、乐观的、向上的（bushi）用法。<br />流程已经趋近工业化。应闭着眼睛都能写出。

```javascript
import axios from 'axios'

const request = aixos.create({
  baseURL: 'http://www.baidu.com',
  timeout: 5000
})

// 下面可以接着定义axios的各种拦截器
// ......

export default request
```

另起一个页面，引入定义好的axios实例，通过它来创建接口方法
```javascript
import request from '@/utils/request'

// 在这里定义一个请求登录的接口
export const postLoginApi = loginData => request.post('/sys/login', loginData)

// 这里还可以使用传入一个options对象的方法创建接口
export const postLoginApi = loginData => request({
  method: 'post', // get方法可以省略
  url: '/sys/login',
  data: { ...loginData } // 可以将形参定为data，那么这里可以简写为 ’data‘
})
```


使用时只需要在页面中按需引入方法。axios返回的是一个promise对象，推荐使用async/await 的方法对结果进行处理。


<a name="de8qS"></a>
### 2.两种拦截器的运用

axios有两个常用的拦截器，请求拦截器和响应拦截器。顾名思义，分别在发送请求时及获取响应时拦截各种数据，从而能在其中做手脚，处理事情，大大方便一些业务的开展

<a name="eZabp"></a>
#### 请求拦截器

相较于响应拦截器，请求拦截器应用的业务范围要小不少，最常见的用法是在发送需要token头部的请求时自动将token添加在请求头部。

请求拦截器有两个回调函数，前面的处理成功时的事物，另一个处理发生错误时的事物。<br />**无论是哪个，记得最后将回调函数的参数返回出去**
```javascript
request.interceptors.request.use(config => {
  // 假设你已经在store存储了一个token
  if（token）config.header.Authorization = store.state.token
  
  // 注意，无论做完什么手脚，一定记得将config返回出去，不然请求发送会失败
  return config
}, err => {
  return Promise.reject(err.message)
})
```


<a name="OlLn8"></a>
#### 响应拦截器

响应拦截器能做的事情就多的去了，毕竟后端代码并不是受我们前端人员控制的，难免有些意见相悖的情况出现。

这个项目中使用响应拦截器做的处理为以下三个：

1. 响应成功时，截取有用的代码片段，摒弃一些用不着的。
1. 有些业务逻辑没出现错误，不会走响应报错，但是确认为非法的事件处理。
1. 当是因为token失效时产生的响应错误，我们应该做相应的处理。
```javascript
request.interceptor.response.use(response => {
  const data = response.data
  if(response.sucess) {
    return data
  } else {
    return Promise.reject(new Error(data.message))
  }
}, err => {
  if (err.response.data.code === 100002) {
    // 当判断当错误的原因是token失效时，处理后续的步骤
    // 通常会清理掉本地储存的token和获取的各种信息
    // 之后将页面导航至登录界面
    ......
  }
  return Promise.reject(err.message)
})
```

注意： 在token失效时，跳转到登录页面，有时需要优化成登陆后仍能返回原页面，这个需求直接使用router.currentRoute.fullPath时会出现bug，解决方式有多种，放在后面说明。



<a name="nCc6v"></a>
## 总结项目中router及路由守卫的运用


该项目中将路由分为静态与动态两种类型，这也是主流项目中的标准做法。后台管理系统的页面权限简单分为两种：需要身份认证的和不需要身份认证的。<br />不需要身份认证的页面，如登录，注册，404，访问权限会宽泛些，而需要身份认证的页面，将严格识别认证标识。

路由守卫可以设置多个，根据处理的业务不同，分开管理。<br />路由首位中的回调函数拥有三个参数，to表示将要跳转到的路由，from表示跳转之前的路由，next表示放行，<br />next中可以重定向将要跳转的路径。


```javascript
router.beforeEach((to, from, next) => {
  

})
```

未完待续。。。
