# call、apply和bind

# call()

使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数 用于改变一个函数的this指向 可以在子构造函数中调用父构造函数的call方法来实现继承 如果调用时不指定第一个参数，则默认指向全局对象。开启严格模式则是undefined

# apply()

作用与call基本一致，只是后续提供的参数需放入一个数组。 根据这一特性，可以实现以下需求： 将一个数组中的数据追加放入另一个数组。 求一个数组中的最大值或最小值。（Math.max.apply(null, [1,2,3,4,5])）

**call和apply都会返回给定this及参数的函数调用后的返回值（立即调用）**

# bind()

写法与call基本相似，不同点是返回值是原函数的拷贝，并拥有指定的 **this** 值和初始参数（不立即调用）。 bind的返回值会创建一个绑定函数，调用这个绑定函数会执行包装函数。包装函数具有以下内部属性：

- **[[BoundTargetFunction]]** - 包装的函数对象
- **[[BoundThis]]** - 在调用包装函数时始终作为 **this** 值传递的值。
- **[[BoundArguments]]** - 列表，在对包装函数做任何调用都会优先用列表元素填充参数列表。
- **[[Call]]** - 执行与此对象关联的代码。通过函数调用表达式调用。内部方法的参数是一个**this**值和一个包含通过调用表达式传递给函数的参数的列表。

调用绑定函数时，会执行包装的函数对象 **BoundTargetFunction** 内部的 **[[Call]]** 方法，call的参数依次是 **[[BoundThis]]** 和 **[[BoundArguments]]** 简单来说，bind也能看作时call方法的一种变体，只不过使用的场景与 call 有着严格区分。 主要用于改变某个函数的this指向，但是又不想立即调用它拿到返回值。 bind返回的绑定函数可以接收另外的参数，这些参数会被传递到 **[[BoundArguments]]** 参数的后面。 所以，用bind封装可以使一个函数拥有初始参数。